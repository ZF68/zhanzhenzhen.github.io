<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Wishlist Tutorial</title>
    <link rel="stylesheet" href="../highlight-custom.css" type="text/css" />
    <link rel="stylesheet" href="../manual.css" type="text/css" />
    <script src="../doc-html.js" type="text/javascript"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-19880790-4', 'auto');
        ga('send', 'pageview');
    </script>
    <script src="../3rd-party/highlight/highlight.pack.js" type="text/javascript"></script>
    <script src="wishlist.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        var Test = npmWishlist.Test;
        document.addEventListener("DOMContentLoaded", function() {
            var naturalLangs = ["en", "zh"];
            var programLangs = ["js", "coffee"];
            var navigatorLang = navigator.language;
            // for IE 9, 10
            if (navigatorLang === undefined) {
                navigatorLang = navigator.userLanguage;
            }
            if (navigatorLang.search(/^zh(-.*)?$/) !== -1) {
                setLang("zh", naturalLangs);
            }
            else {
                setLang("en", naturalLangs);
            }
            setLang("js", programLangs);
            document.getElementById("preferJS").addEventListener("click", function() {
                setLang("js", programLangs);
                location.href = "#setLang";
            });
            document.getElementById("preferCoffee").addEventListener("click", function() {
                setLang("coffee", programLangs);
                location.href = "#setLang";
            });
            document.getElementById("referenceLink").addEventListener("click", function() {
                location.href = "#reference";
            });
            document.getElementById("githubLink").addEventListener("click", function() {
                location.href = "https://github.com/zhanzhenzhen/wishlist";
            });
            document.getElementById("englishButton").addEventListener("click", function() {
                setLang("en", naturalLangs);
            });
            document.getElementById("chineseButton").addEventListener("click", function() {
                setLang("zh", naturalLangs);
            });
            document.getElementById("downloadLink").href =
                    "https://github.com/zhanzhenzhen/wishlist/archive/v0.3.2.zip";
            setTimeout(function() {
                document.getElementById("demo").play();
            }, 1000);
            hljs.initHighlighting();
        });
    </script>
</head>
<body>
<table style="border-bottom: 0.15rem solid rgb(128,128,128);"><tr>
    <td style="width: 20%;">
        <span style="font-family: Quando; font-weight: 400; font-size: 4em;">wishlist</span>
    </td>
    <td style="width: 80%; text-align: right;">
        <div id="englishButton" class="button grey" style="display: inline-block;">English</div>
        <div id="chineseButton" class="button grey" style="display: inline-block;">中文</div>
        <div id="githubLink" class="button grey" style="display: inline-block;">GitHub</div>
    </td>
</tr></table>
<p><span class="en">Wishlist is a new concept testing framework for browsers and Node.js. It makes your test more natural, more readable, less redundant, and thus speeds up your test writing.</span><span class="zh">Wishlist是一个新型的测试框架，它可以在浏览器和Node.js下运行，它使你的测试变得更自然、可读性更强、代码长度更短，从而提升你的测试代码的编写速度。</span></p>
<p style="border-left: 0.6em solid rgb(224,224,224); padding-left: 1em;"><video id="demo">
    <source src="demo.mp4" type="video/mp4" />
    <source src="demo.webm" type="video/webm" />
</video></p>
<div id="setLang" style="margin-top: 1rem;">
    <div id="preferJS" class="button blue" style="display: inline-block;"><span class="en">I prefer JavaScript</span><span class="zh">我偏好JavaScript</span></div>
    <div id="preferCoffee" class="button blue" style="display: inline-block;"><span class="en">I prefer CoffeeScript</span><span class="zh">我偏好CoffeeScript</span></div>
    <div id="referenceLink" class="button grey" style="display: inline-block;"><span class="en">Reference</span><span class="zh">参考</span></div>
</div>
<h2><span class="en">Usage</span><span class="zh">使用</span></h2>
<h3><span class="en">Try Wishlist:</span><span class="zh">试试Wishlist：</span></h3>
<p><span class="en">This page has already loaded Wishlist and simplified the Test namespace, so just try it in the web console. If you want to use Wishlist in your project, please follow the steps below.</span><span class="zh">本页面已经加载了Wishlist并且简化了Test的命名空间，所以你可以在Web控制台直接试验。如想在你的项目中使用Wishlist，那么请使用下面的方法。</span></p>
<ul>
    <li>
        <p><span class="en">Node.js:</span><span class="zh">Node.js：</span></p>
        <pre>
            <code class="js">
                var Test = require("wishlist").Test;
            </code>
            <code class="coffee">
                Test = require("wishlist").Test
            </code>
        </pre>
    </li>
    <li>
        <p><span class="en">Browser:</span><span class="zh">浏览器：</span></p>
        <p><a id="downloadLink" href="#downloadLink"><span class="en">Download</span><span class="zh">下载</span></a><span class="en">, then</span><span class="zh">，然后</span></p>
        <pre><code class="xml">
            &lt;script src="wishlist.min.js" type="text/javascript"&gt;&lt;/script&gt;
        </code></pre>
        <p><span class="en">then</span><span class="zh">然后</span></p>
        <pre>
            <code class="js">
                var Test = npmWishlist.Test;
            </code>
            <code class="coffee">
                Test = npmWishlist.Test
            </code>
        </pre>
    </li>
</ul>
<h2><span class="en">Test</span><span class="zh">测试</span></h2>
<p><span class="en">Nowadays there are many testing frameworks claiming that they are simple, but actually they are not simple. The key point is that the code style for testing is very different from the code style we're familiar with. For example, if you have a variable money = 900, but the expected value should be 1000, if you write:</span><span class="zh">当今世界有许多测试框架，它们都声称很简洁，但实际并非如此。原因是测试代码的风格与我们熟悉的编程风格大不相同。例如，你有一变量 money = 900，但期望值是1000，如果你这样写的话：</span></p>
<pre>
    <code class="js">
        assert(money === 1000)
    </code>
    <code class="coffee">
        assert(money == 1000)
    </code>
</pre>
<p><span class="en">This will only tell you the assertion has failed. No more info. Because it's equivalent to <code>assert(false)</code>. So you want it to show the expected and actual values. Then you may write:</span><span class="zh">这只会显示出断言失败，除此之外没有其他的信息，因为这等价于<code>assert(false)</code>。所以最好应能分别显示出期望值和实际值是多少。然后你也许会这样写：</span></p>
<pre><code class="js">
    assert.strictEqual(money, 1000)
</code></pre>
<p><span class="en">Already looks a bit weird. Further, if your test has many assertions, you often give it a name for each in order to know which caused the error:</span><span class="zh">这种风格已经看上去不那么好看了。更糟的是，当你有非常多的断言时，你需要给每一个断言命名，以知道究竟是哪个断言出错了：</span></p>
<pre><code class="js">
    assert.strictEqual(money, 1000, "money equals 1000")
</code></pre>
<p><span class="en">But it's redundant. Why must we write <code>money</code>, <code>strictEqual</code>, <code>1000</code> as well as <code>"money equals 1000"</code>? Wishlist solved all these problems. Via Wishlist, you will only write:</span><span class="zh">这儿有冗余。为什么我们写<code>money</code>、<code>strictEqual</code>、<code>1000</code>的同时，还必须写上<code>"money equals 1000"</code>？Wishlist解决了所有这些问题。在Wishlist中，你只要写：</span></p>
<pre><code class="js">
    I.wish('money=1000')
</code></pre>
<p><span class="en">That's all.</span><span class="zh">这就是全部。</span></p>
<p><span class="en">Here's an example:</span><span class="zh">一个例子：</span></p>
<pre>
    <code class="js">
        new Test()
        .add("String methods", function(my, I) {
            my.str = "hello world";
            I.wish(' str.charAt(3)="l" ');
            I.wish(' str.split(" ")=["hello","world"] ');
        }).run();
    </code>
    <code class="coffee">
        new Test()
        .add("String methods", (my, I) ->
            my.str = "hello world"
            I.wish(' str.charAt(3)="l" ')
            I.wish(' str.split(" ")=["hello","world"] ')
        ).run()
    </code>
</pre>
<p><span class="en">Here <code>my</code> means the environment and <code>I</code> means the test. I recommend those name pairs:</span><span class="zh">这儿<code>my</code>表示环境(environment)，<code>I</code>表示该测试(test)。我推荐这几个名字：</span></p>
<ul>
    <li><code>env,test</code> <small><span class="en">(canonical)</span><span class="zh">（正规）</span></small></li>
    <li><code>v,t</code> <small><span class="en">(short)</span><span class="zh">（短）</span></small></li>
    <li><code>my,I</code> <small><span class="en">(cool)</span><span class="zh">（酷）</span></small></li>
</ul>
<p><span class="en">Wishes can also be described by an argument after the test function. These will be checked once the test function call is complete. If all wishes are in this format, then there's no need to have the second argument <code>I</code> in the test function:</span><span class="zh">wish也可以放在测试函数的后面。一旦测试函数运行完，这些wish就会被检测。如果所有wish都以这种格式表示，那么测试函数的第二个参数<code>I</code>就可以省略：</span></p>
<pre>
    <code class="js">
        new Test()
        .add("String methods", function(my) {
            my.str = "hello world";
        }, [
            ' str.charAt(3)="l" ',
            ' str.split(" ")=["hello","world"] '
        ]).run();
    </code>
    <code class="coffee">
        new Test()
        .add("String methods", (my) ->
            my.str = "hello world"
        , [
            ' str.charAt(3)="l" '
            ' str.split(" ")=["hello","world"] '
        ]).run()
    </code>
</pre>
<p><span class="en">The array can be replaced with a string of wishes delimited by ";". So this array is equivalent to:</span><span class="zh">这个数组可以用一个以";"分隔的字符串来代替，所以该数组等同于：</span></p>
<pre><code class="js">
    ' str.charAt(3)="l"; str.split(" ")=["hello","world"] '
</code></pre>
<p><span class="en">In a wish string, the operator "=" means <b>deep equal</b>. It's identical to <b>strict equal</b> if operands are not objects or arrays. Note that when its strict equal it's very strict. Even +0 is not equal to -0.</span><span class="zh">在wish字符串中，"="意为deepEqual。当两边都不是对象或数组时，它等价于strictEqual。请注意它的strict是非常严格的，甚至+0和-0都不相等。</span></p>
<p><span class="en">To distinguish +0 and -0 is useful in test cases. For example, you want to make sure your custom <b>length</b> property does not return -0. (Trick: In the web sonsole, you can test if a variable <code>n</code> is +0 or -0 by using <code>1 / n</code>.)</span></span><span class="zh">把+0和-0区别开来，这在测试场景中很有用，例如你总不希望你的自定义length属性返回的是-0。（小技巧：在Web控制台中你可以使用<code>1 / n</code>来测试变量<code>n</code>是+0还是-0。）</span></p>
<p><span class="en">You may be interested in: What will it display when a wish is broken? So, we modify the 3rd line to <code>my.str = "helloooo world"</code> and run it again. It shows:</span><span class="zh">你可能已经对这个问题感兴趣了：如果一个wish失败，会显示什么呢？下面我们就把第3行改为<code>my.str = "helloooo world"</code>重新运行后，显示：</span></p>
<pre>
    ********** Broken Wish **********
        Test:  --> String methods
        Wish: str.split(" ")=["hello","world"]
    Expected: = ["hello","world"]
      Actual: ["helloooo","world"]
</pre>
<p><span class="en">If you want to customize a wish's description, you can use a ":". See reference for details.</span><span class="zh">如果你想自定义某个wish的描述，可以使用":"。具体请看参考。</span></p>
<p><span class="en">There are other operators such as "is" and "throws". <code>I.wish(' obj1 is obj2 ')</code> will test if obj1 and obj2 are the same object. See reference for details.</span><span class="zh">其他的运算符有is、throws等。<code>I.wish(' obj1 is obj2 ')</code>会测试obj1和obj2是否是同一对象。更多运算符的介绍请看参考。</span></p>
<h2><span class="en">Asynchronous Test</span><span class="zh">异步测试</span></h2>
<p><span class="en">Wishlist supports <b>asynchronous</b> test. Let's extend the above example to:</span><span class="zh">Wishlist支持异步测试。现在我们把上面的例子扩展为：</span></p>
<pre>
    <code class="js">
        new Test()
        .add("String methods", function(my) {
            my.str = "hello world";
        }, ' str.charAt(3)="l"; str.split(" ")=["hello","world"] ')
        .addAsync(function(my, I) {
            my.a = 10;
            setTimeout(function() {
                my.b = 10;
                I.end();
            }, 2500);
        }, 'b=a')
        .run();
    </code>
    <code class="coffee">
        new Test()
        .add("String methods", (my) ->
            my.str = "hello world"
        , """
            str.charAt(3)="l";
            str.split(" ")=["hello","world"]
        """)
        .addAsync((my, I) ->
            my.a = 10
            setTimeout(->
                my.b = 10
                I.end()
            , 2500)
        , 'b=a')
        .run()
    </code>
</pre>
<p><span class="en">An <code>I.end()</code> is to notify Wishlist that the async test has ended.</span><span class="zh"><code>I.end()</code>是用来通知Wishlist，这个异步test已经结束了。</span></p>
<h2><span class="en">Advanced</span><span class="zh">进阶</span></h2>
<p><span class="en"><b>Test</b> can be nested to any level. In fact the above example creates 3 tests (not 2): the root test and 2 child tests. The root test, created by a <b>constructor</b>, in this example is used as a container and can invoke the <b>run</b> method. The <b>add</b> method creates a child test. You can also use a <b>constructor</b> within the <b>add</b> method to create multi-level tests. For details, see the reference.</span><span class="zh">Test可以无限嵌套。事实上，上面的例子创建了3个测试（不是2个）：根测试和2个子测试。根测试以构造器的形式创建，在本例中仅作为一个容器，且能调用run方法。add方法创建一个子测试。你也可以在add方法中使用构造器来创建多层测试，详细内容请看参考。</span></p>
<p><span class="en">Consider the testing as two things: test and wish. A test can have 0, 1, or more wishes, and can have child tests. That's all.</span><span class="zh">测试的整体架构其实只有两个元件：test和wish。test可以包含0个、1个或更多个wish，也可以包含“子test”，这就是全部。</span></p>
<p><span class="en">You may have come across this situation when using other testing frameworks: It reports 15 broken units. After fixing a bug and running the tests again, it still reports 15. But maybe it's because 2 of them are new, while 2 of the old ones disappeared this time? So in this case the result summary can be misleading. That's why we added a <b>mark</b>. Mark is a 5-char string. If Mark is changed, you will immediately be aware that the results must have been changed, so you can make a deep analysis on the whole results.</span><span class="zh">你可能在使用其他测试框架时遇到这个场景：它报告了15个单元失败，等到bug修复好再重新运行测试，它仍然报告15个单元失败。但也许是因为其中2个是新失败的单元，而另2个原先失败的单元这次正好成功了呢？所以测试报告可以是误导的。这就是为什么我们加入mark。mark是一个5长度的字符串，如果mark改变，那你就立即可以察觉到测试结果必然已有变化，然后你就可以静下心来仔细看整个报告。</span></p>
<p><span class="en">Mark value is the first 5 character of the SHA-256 hash of the sequence of all wishes' results.</span><span class="zh">mark值是所有wish的检测结果所组成的序列的SHA-256哈希值的前5位。</span></p>
<p><span class="en">A difference between Wishlist and other testing frameworks is that it's not assertion style. That means even if a wish fails, the next wish will still be executed. It's a good feature because the result will be more meaningful if all wishes can be covered. (In fact I think <b>assert</b> is better to be used in validating parameters in a function than in testing.)</span><span class="zh">Wishlist和许多测试框架还有个区别就是，它并非“断言”式，这意味着如果一个wish失败，下一个wish依然会被执行。这是一个良好的特性，因为在测试中并不需要像在其他代码中那样使用assert来“过滤”来避免错误，相反，使所有wish都能被覆盖到，能使测试结果更有意义。（事实上，我认为assert更适合在函数中检查参数，而非用来测试。）</span></p>
<p><span class="en">All tests in the same level are run in parallel. In future versions we will add more options.</span><span class="zh">同一层中的所有test都是并行执行。以后的版本中会加入更多的控制功能。</span></p>
<h1 id="reference"><span class="en">Reference</span><span class="zh">参考</span></h1>
<ol>
    <li id="reference_wishlist">wishlist
        <div>
            <p><span class="en">In this reference, <code>wishlist</code> refers to the return value of Node's <code>require("wishlist")</code>, or browser's <code>npmWishlist</code>.</span><span class="zh">在本参考中，<code>wishlist</code>指Node的<code>require("wishlist")</code>返回值，以及浏览器的<code>npmWishlist</code></span>。</p>
            <p><span class="en">FYI: Browser's "npm" prefix is to avoid possible naming conflicts.</span><span class="zh">浏览器的npm前缀只是用来尽量避免可能的命名冲突。</span></p>
        </div>
        <ul>
            <li>wishlist.Test<div>
                <p><span class="en">This class represents a test.</span><span class="zh">这个类表示一个测试。</span></p>
            </div></li>
        </ul>
    </li>
    <li id="reference_wishlist.Test">wishlist.Test
        <ul>
            <li><span class="en">Constructor</span><span class="zh">构造器</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">new wishlist.Test([description])</code></p>
                <p><span class="en">Creates a new <b>wishlist.Test</b> object with an optional <b>description</b>.</span><span class="zh">创建一个新的测试，并设定它的描述为description。</span></p>
            </div></li>
            <li><span class="en">Test Function</span><span class="zh">测试函数</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">function(environment, [test]) {...}</code></p>
                <p><span class="en">Note that environment variables (i.e. properties) declared in the function can be seen by not only the test itself but also its child tests (but cannot be seen by its parent tests).</span><span class="zh">注意：本函数内声明的环境变量不但在test内可见，在它的子test内也是可见的（但在它的父test内是不可见的）。</span></p>
                <p><span class="en">The following are reserved names, which may be used by our future version, so don't use them as environment variable (property) names:</span><span class="zh">下面列出的是保留字，将来的版本有可能会使用到，所以不要把它们作为环境变量名：</span></p>
                <ul>
                    <li>wish</li>
                    <li>wishes</li>
                    <li>finish</li>
                </ul>
            </div></li>
            <li>set<div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">test.set([description], testFunction, [wishes])</code></p>
                <p><span class="en">Sets the test's <b>description</b>, <b>function</b> and <b>wishes</b>, returning the test. <code>wishes</code> can be either a string or an array.</span><span class="zh">设置该test的description、function和wishes。wishes可以是字符串，也可以是数组。</span></p>
                <p><span class="en">This method is useful if you want to set the test's function and also want the test to be the parent of several child tests. For example:</span><span class="zh">当你既想设置该test的函数，又想让它包含子test时，这个方法就很有用。例如：</span></p>
                <pre>
                    <code class="js">
                        new Test("root")
                        .set(function(v, t) {
                            t.wish("true=true");
                        })
                        .add("test 1", function(v, t) {
                            t.wish("false=false");
                        })
                        .add("test 2", function(v, t) {
                            t.wish("true=true");
                        }).run();
                    </code>
                    <code class="coffee">
                        new Test("root")
                        .set((v, t) ->
                            t.wish("true=true")
                        )
                        .add("test 1", (v, t) ->
                            t.wish("false=false")
                        )
                        .add("test 2", (v, t) ->
                            t.wish("true=true")
                        ).run()
                    </code>
                </pre>
                <p><span class="en">This example sets the root test's function. Child tests "test 1" and "test 2" will be run once the root test function call is complete.</span><span class="zh">这段代码设置了根测试的函数。子测试 test 1 和 test 2 会在根测试完成之后立即运行。</span></p>
                <p><span class="en">Note that even if the test function is not set, it still has an empty function. So all tests have functions.</span><span class="zh">注意：即使你没有设置测试函数，该测试仍然有一个空的函数，所以事实上所有的测试都有测试函数。</span></p>
            </div></li>
            <li>setAsync<div>
                <p><span class="en">Similar to <code>set</code>, except that it's asynchronous.</span><span class="zh">类似<code>set</code>，除了它是异步的。</span></p>
            </div></li>
            <li>add<div>
                <p><span class="en">Syntax 1: </span><span class="zh">语法1：</span><code class="syntax">test.add([description], testFunction, [wishes])</code><br />
                <span class="en">Syntax 2: </span><span class="zh">语法2：</span><code class="syntax">test.add(childTest)</code></p>
                <p><span class="en">For syntax 1, creates a new test and add it as a child of the current object, returning the current object. The arguments syntax is equivalent to <code>set</code> arguments syntax.</span><span class="zh">对于语法1，创建一个新test，将其作为子test添加到当前对象中，返回当前对象。这些参数的语法和<code>set</code>中参数的语法相同。</span></p>
                <p><span class="en">For syntax 2, Adds an existing test as child, returning the current object.</span><span class="zh">对于语法2，加入一个现存的test作为子test，返回当前对象。</span></p>
                <p><span class="en">Syntax 2 is useful in building nested tests. For example:</span><span class="zh">语法2在构建嵌套测试中很有用，例如：</span></p>
                <pre>
                    <code class="js">
                        new Test()
                        .add("test 1", function(v, t) {
                            t.wish("true=true");
                        })
                        .add(
                            new Test("test 2")
                            .add("first test in test 2", function(v, t) {
                                t.wish('false=false');
                            })
                            .add("second test in test 2", function(v, t) {
                                t.wish("false=true");
                            })
                        ).run();
                    </code>
                    <code class="coffee">
                        new Test()
                        .add("test 1", (v, t) ->
                            t.wish("true=true")
                        )
                        .add(
                            new Test("test 2")
                            .add("first test in test 2", (v, t) ->
                                t.wish('false=false')
                            )
                            .add("second test in test 2", (v, t) ->
                                t.wish("false=true")
                            )
                        ).run()
                    </code>
                </pre>
                <p><span class="en">In this example, the root test has two child tests "test 1" and "test 2", and "test 2" has two child tests "first test in test 2" and "second test in test 2".</span><span class="zh">在这个例子中，根测试有2个子测试 test 1 和 test 2，而 test 2 又有2个子测试 first test in test 2 和 second test in test 2。</span></p>
            </div></li>
            <li>addAsync<div>
                <p><span class="en">Adds a new asynchronous child test. Its syntax is similar to <code>add</code> syntax 1.</span><span class="zh">添加一个异步测试作为子测试。语法类似<code>add</code>语法1。</span></p>
            </div></li>
            <li>after<div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">test.after(fun)</code></p>
                <p><span class="en">Sets the "after" function. "After" function will be called as soon as all descendant tests (including itself) are finished. "After" function is similar to a test function, but only takes one argument <code>environment</code>.</span><span class="zh">设置after函数。after函数会在所有后代测试（包括它自己）结束后被调用。after函数类似测试函数，但只有一个参数<code>environment</code>。</span></p>
            </div></li>
            <li>run<div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">test.run()</code></p>
                <p><span class="en">Runs the test and all its child tests, returning the current object. Note that you should only call <code>run</code> for the root test.</span><span class="zh">运行该测试和它的所有子测试，返回当前对象。注意：你应当只对根测试使用<code>run</code>。</span></p>
            </div></li>
            <li>end<div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">test.end()</code></p>
                <p><span class="en">Notifies Wishlist that the async test has ended.</span><span class="zh">通知Wishlist该异步测试结束。</span></p>
            </div></li>
            <li>wish<div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">test.wish(wishes)</code></p>
                <p><span class="en">Declares <code>wishes</code> and checks them. <code>wishes</code> is a string representing one or more wishes splitted by ";". A wish can contain a colon ":". The text on the right side of ":" is the wish description. The text on the left side of ":" is the wish body. If description is specified, then it will be used rathan than the body in the displayed result. An example:</span><span class="zh">声明<code>wishes</code>并检测它们。<code>wishes</code>是一个以分号";"分隔的表示一个或多个wish的字符串。一个wish可以含有一个冒号":"。冒号右边的是该wish的描述，冒号左边的是该wish的主体。如果指定了描述，那么在结果中就会显示描述而不是主体。示例：</span></p>
                <pre><code class="js">
                    test.wish("true=true: my wish; false=false: my another wish")
                </code></pre>
                <p><span class="en">Inside a wish body, there are 1 or 2 expressions to be compared or checked. Don't use CoffeeScript-only symbols such as "@" and "::" in an expression.</span><span class="zh">wish主体含有1到2个用来被比较或检测的表达式。不要在表达式中使用CoffeeScript专用符号，如"@"和"::"。</span></p>
                <p><span class="en">A wish body must match one of the following 10 patterns:</span><span class="zh">wish主体必须匹配下面10个模式之一：</span></p>
            </div></li>
            <li><span class="en">"=" pattern</span><span class="zh">"="模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}={expected}"</code></p>
                <p><span class="en">The operator "=" means <b>deep equal</b>. It's identical to <b>strict equal</b> if operands are not objects or arrays. Note that unlike other frameworks, in Wishlist "NaN=NaN" passes and "+0=-0" fails.</span><span class="zh">运算符"="表示深层相等（deep equal）。当等号两边不是对象或数组时，它等价于严格相等（strict equal）。注意：和其他的测试框架不同，在Wishlist中，"NaN=NaN"会成功，而"+0=-0"则会失败。</span></p>
            </div></li>
            <li><span class="en">"<>" pattern</span><span class="zh">"<>"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}<>{notExpected}"</code></p>
                <p><span class="en">Tests if two values are not equal. Opposite of "=" pattern.</span><span class="zh">检测两个值是否不相等。它是"="的反运算。</span></p>
            </div></li>
            <li><span class="en">"is" pattern</span><span class="zh">"is"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual} is {expected}"</code></p>
                <p><span class="en">The operator "is" is equivalent to <b>strict equal</b> (i.e. JavaScript's <code>===</code>), except that "NaN is NaN" passes and "+0 is -0" fails.</span><span class="zh">运算符"is"表示严格相等（strict equal，即JavaScript的<code>===</code>），除了这两个例外："NaN is NaN"将会成功，"+0 is -0"将会失败。</span></p>
            </div></li>
            <li><span class="en">"isnt" pattern</span><span class="zh">"isnt"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual} isnt {expected}"</code></p>
                <p><span class="en">Opposite of "is" pattern.</span><span class="zh">"is"的反运算。</span></p>
            </div></li>
            <li><span class="en">"throws" pattern</span><span class="zh">"throws"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{function} throws [{expected}]"</code></p>
                <p><span class="en">Tests if a callback throws an exception, and optionally compare the thrown error. If <b>expected</b> is specified, it can be either a class or a regular expression.</span><span class="zh">检测一个回调函数是否抛出异常（也可指定抛出何种异常）。如果指定expected，那么它可以是一个类，也可以是一个正则表达式。</span></p>
            </div></li>
            <li><span class="en">"does not throw" pattern</span><span class="zh">"does not throw"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{function}"</code></p>
                <p><span class="en">If the wish body comprises a function only, then it matches this pattern. It tests if a callback does not throw an exception.</span><span class="zh">如果wish主体仅为一个函数，那么就匹配该模式。它检测一个回调函数是否不抛出任何异常。</span></p>
            </div></li>
            <li><span class="en">"<" pattern</span><span class="zh">"<"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}<{refValue}"</code></p>
                <p><span class="en">Tests if <b>actual</b> is less than <b>refValue</b>.</span><span class="zh">检测实际值是否小于参考值。</span></p>
            </div></li>
            <li><span class="en">">" pattern</span><span class="zh">">"模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}>{refValue}"</code></p>
                <p><span class="en">Tests if <b>actual</b> is greater than <b>refValue</b>.</span><span class="zh">检测实际值是否大于参考值。</span></p>
            </div></li>
            <li><span class="en">"<=" pattern</span><span class="zh">"<="模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}<={refValue}"</code></p>
                <p><span class="en">Tests if <b>actual</b> is less than or equal to <b>refValue</b>.</span><span class="zh">检测实际值是否小于或等于参考值。</span></p>
            </div></li>
            <li><span class="en">">=" pattern</span><span class="zh">">="模式</span><div>
                <p><span class="en">Syntax: </span><span class="zh">语法：</span><code class="syntax">"{actual}>={refValue}"</code></p>
                <p><span class="en">Tests if <b>actual</b> is greater than or equal to <b>refValue</b>.</span><span class="zh">检测实际值是否大于或等于参考值。</span></p>
            </div></li>
        </ul>
    </li>
</ol>
</body>
</html>
