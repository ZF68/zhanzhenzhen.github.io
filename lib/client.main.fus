fus 2.0.6
import "babel-polyfill"
import "./shared.manifest" all

shared: import "site/shared"
#import "./shared.main"
client: import "site/client"

marked: import "marked"
#manuals: require("./client.manuals.coffee")
ui: client.ui

docsObj: {}
originalTitle: document.title

parseElement: s -> DOMParser().parseFromString(s, "application/xml").documentElement

ui.setRem(0.02)

contentElement: ui.Element(
    {
        width: 0.8
        overflow: "scroll"
        lineHeight: 1.5
        selectable: true
        pointer: "auto"
        padding: "0.5rem"
    }
)
ui.root.add(
    ui.Stack(
        {
            width: "auto"
            aspectRatio: 1.25
            horizontal: true
        },
        ui.Stack{
            width: 0.2
            childSpacing: "0.3rem"
            padding: ui.Padding(0, "2rem", 0, 0)
        } as leftCol,
        contentElement
    )
)
Promise.all(client.text.map(doc ->
    if (doc.filename.endsWith(".md") or doc.filename.endsWith(".markdown"))
    and doc.content.startsWith("<script ")
        pos: doc.content.search("</script>")
        metaString: doc.content.substr(0, pos + "</script>".length)
        metaElement:
            DOMParser().parseFromString(metaString, "text/html")
            .querySelector("script[type=\"application/ld+json\"]")
        fileType: "markdown"
    (
        if metaElement'ok
            shared.jsonLd.compact(
                JSON.parse(metaElement.textContent),
                {"@context": "http://schema.org/"}
            )
        else
            Promise.resolve{}
    ).then(meta ->
        candidateId: doc.filename.substr(0, doc.filename.lastIndexOf("."))
        {
            title: meta.headline ifnull "no title"
            time: Date(meta.dateCreated ifnull "2010-01-02T00:00Z")
            type: fileType
            id: match candidateId
                ""     ? null
                "home" ? ""
                |        candidateId
            content: doc.content
        }
    )
)).then(rawDocs ->
    docs: rawDocs.filter(m -> m.type'ok and m.id'ok)
    docs.forEach doc ->
        docsObj.(doc.id): doc
    groups: docs..group(m ->
        if m.id = ""
            "home"
        else if m.id.match(r"^\d\d\d\d_\d\d_\d\d($|_)")'ok
            "blog"
        else
            "article"
    )
    homeGroup: groups..singleOrNull(m -> m.0 = "home")
    blogGroup: groups..singleOrNull(m -> m.0 = "blog")

    if homeGroup'ok
        leftCol.add(ui.Text(homeGroup.1.0.title, {
            padding: ui.Padding("0.5rem")
            backgroundPaint: "rgb(224,224,224)"
            pointer: "link"
            click: <> client.setUri("/")
        }))

    if blogGroup'ok
        blogGroup.1..sortDescending(m -> m.time).forEach(blog ->
            date: blog.time
            dateStr: date.getUTCFullYear()..pad(4) + "-"
                + (date.getUTCMonth() + 1)..pad(2) + "-"
                + date.getUTCDate()..pad(2)
            leftCol.add(ui.Stack(
                {
                    height: "auto"
                    padding: ui.Padding("0.5rem")
                    backgroundPaint: "rgb(224,224,224)"
                    pointer: "link"
                    click: <> client.setUri("/" + blog.id)
                },
                ui.Text(blog.title),
                ui.Text(dateStr, {fontSize: 0.7})
            ))
        )

    oldPath: null
    uriUpdateHandler: <>
        path: decodeURI(location.pathname)
        if path â‰  oldPath

            contentElement.empty()

            strippedPath: path.substr(1)
            if strippedPath.endsWith("/")
                strippedPath: strippedPath.substr(0, strippedPath.length - 1)
            doc: docsObj.(strippedPath)

            if doc'ok
                document.title: doc.title
                if doc.type = "markdown"
                    htmlString: marked.parse(doc.content)
                    contentElement.raw.innerHTML: parseElement("
                        <div xmlns="http://www.w3.org/1999/xhtml">
                            \(htmlString)
                        </div>
                    ").innerHTML
                else
                    contentElement.raw.textContent: doc.content
            else
                document.title: ""
                contentElement.raw.textContent: ""

            oldPath: path

    uriUpdateHandler()
    client.onUriChange(uriUpdateHandler)
)
